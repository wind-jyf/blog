# 计算机网络

## 应用层

#### 1. Get和Post的区别

* 从应用场景上来讲
  * Get适用于向服务器请求资源，对服务器资源不会产生影响，是一个幂等的请求
  * Post不是一个幂等的请求，主要用于对服务器资源会产生影响的场景下。
* 从缓存上来讲
  * 由于应用场景的不同，浏览器会对Get请求进行缓存
  * 但是很少对Post请求缓存
* 从参数上来讲
  * Get的参数一般放在URL中。
  * Post的参数一般放在请求体，更适合传递敏感信息。
* 从编码上讲
  * GET只能进行URL编码，它只能接收ASCII字符
  * 但是POST没有限制。
* 从TCP角度讲
  * Get请求会一次性将报文发送出去
  * Post一般会分为两个TCP数据包，首先发送的是header部分，如果服务器响应100，则继续发送body部分，但火狐浏览器除外，它一次Post请求只会发送一次TCP数据包。

#### 2. HTTP请求方法

1. Get：获取资源，是幂等操作
2. HEAD：获取报文首部，和Get很像，但是不返回响应体，是幂等操作
3. Post：创建或更新资源，非幂等操作
4. PUT：创建或更新资源本身，幂等操作
5. PATCH：对资源进行局部更新，非幂等操作
6. DELETE：删除资源，和PUT功能相反，幂等操作
7. OPTIONS：查询服务器端支持的HTTP方法种类，是幂等操作
8.  CONNECT：建立连接隧道，用于代理服务器，是幂等操作
9. TRACE：追踪请求，查询发出去的请求是怎样被加工/篡改的，是幂等操作

#### 3. HTTP状态码

###### 1xx 信息性

> 请求已经接收到，需要进一步处理才能完成，但是HTTP1.0不支持

* 101：在HTTP升级为WebSocket时，如果服务器同意变更，则返回101

###### 2xx 成功状态

> 成功处理请求

* 200 OK：请求成功，通常返回的数据中带有响应体
* 204 Not Content：意思是和200一样，只是返回的数据中不带有响应体。
* 206 Partial Content：客户端进行了范围请求且服务端正常处理，响应报文的首部应该还有Content-Range字段指定实体的范围。使用场景为HTTP分块下载和断点续传。

###### 3xx 重定向

> 重定向状态，如果资源位置发生变动，需要重新请求

* 301 Moved Permanently：永久重定向，最新的URI为响应报文首部的location字段。且浏览器默认会做缓存优化，减少服务器压力。
* 302 Found：临时重定向，和301不同，它表示的是资源临时被移动到了别的URI上，因为是暂时的，所以不会被缓存。
* 303 See Other：临时重定向，请求的资源临时被移动到了别的URI上，但是明确表示客户端应该使用GET方法获取资源
* 304 Not Modefied：协商缓存成功就会返回304，表示资源在服务器中并未改变，告诉请求者可以使用缓存。

###### 4xx 客户端错误

> 客户端出现错误

* 400：客户端请求报文中存在语法错误
* 401：需要有通过HTTP认证的认证信息或者表示用户认证失败
* 403：请求资源被拒绝，原因是：比如法律进行、信息敏感。
* 404：请求资源并未找到，表示没有在服务器上找到相应的资源。

###### 5xx 服务端出现错误

> 服务端出现错误

* 500：服务器内部错误
* 501：表示客户端请求的功能还不支持
* 502：服务器自身是正常的，但是代理服务器无法获取到合法响应（点外卖时外卖小哥没送）
* 503：服务内部处于超负载状态或停机维护（就像是本店今天不开张）

#### 4. HTTP首部有哪些

* 通用首部字段：请求报文和响应报文双方都会使用的首部
  * Cache-Control 控制缓存
  * Connection 连接管理
  * Date 表示报文创建的日期
  * Transfor-Encoding 报文主体的传输编码格式
    * HTTP/1.1中仅对分块传输编码有效，Transfor-Encoding:chunked
* 请求首部字段
  * Accept 客户端或者代理能够处理的媒体类型
  * If-Match 比较实体标记（ETage）
  * If-None-Match 比较实体标记（ETage）与 If-Match相反
  * If-Modified-Since 比较资源更新时间（Last-Modified）
  * If-Unmodified-Since比较资源更新时间（Last-Modified），与 If-Modified-Since相反
  * Range 实体的字节范围请求
  * Authorization web的认证信息
  * Host 请求资源所在服务器 
  * User-Agent 客户端程序信息
* 响应首部字段
  * Location 令客户端重定向的URI 
  * ETag 能够表示资源唯一资源的字符串 
  * Server 服务器的信息
* 实体首部字段：针对请求和响应报文的实体部分使用的首部字段
  * Allow 资源可支持http请求的方法
  * Last-Modified 资源最后的修改资源
  * Expires 实体主体的过期资源

#### 5. HTTP中的keep-alive

在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

目前对于同一个域，大多数浏览器支持同时建立6个持久连接。

keep-alive的优点：

* 较少的CPU和内存的使用（由于同时打卡的连接减少了）
* 降低拥塞控制（TCP连接减少了）
* 减少了后续请求的延迟（无需再进行握手）
* 报告错误无需关闭TCP连接

#### 6. HTTP2相对于HTTP1.X有什么优势和特点

###### 二进制协议

HTTP/2是一个二进制协议。在HTTP/1.1版中，报文的头信息必须是文本（ASCII）编码，数据体可以是文本，也可以是二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”，可以分为头信息帧和数据帧。帧的概念是多路复用的基础。

###### 多路复用

HTTP/2实现了多路复用，HTTP/2仍然复用TCP连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了“队头阻塞”的问题。

###### 数据流

HTTP/2使用了数据流的概念，因为HTTP/2是不按照顺序发送的，同一个连接里面有连续的数据包，可能属于不同的请求。因此必须要对数据包做标记，指出它属于哪个请求。HTTP/2将每个请求或回应的所有数据包成为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分属于哪一个数据流。

###### 头信息压缩

HTTP/2实现了头信息压缩，由于HTTP协议1.1不带状态，所以每次请求必须附上所以的信息，因此很多字段都是重复的，比如Cokkie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

于是，引入了头信息压缩机制。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段会存入这个表，生成一个索引号，以后就不需要发送同样字段了，只需发送索引号。

###### 服务器推送

HTTP/2允许服务器未经允许主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源，这样就可以相对减少一些延迟的时间。

#### 7. HTTP/2协议缺点

因为HTTP/2使用了多路复用，一般来说同一个域名下只需要使用一个TCP连接。由于多个数据流使用同一个TCP连接，遵守同一个流量控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被拥塞。

HTTP/2出现的这个问题是由于其使用TCP协议的问题，与它本身的实现并没有太大的问题。

#### 8. HTTPS协议

###### HTTP协议存在的问题

* HTTP协议报文使用明文方式发送，可能被第三方窃听
* HTTP报文可能被第三方截取篡改，但接收方没有办法发现内容的修改
* HTTP还存在认证问题，第三方可以冒充他人参与通信

###### TLS握手

* 传统的TLS握手也就是RSA握手
* 现在主流的TLS1.2版本的握手，也就是ECDHE握手

###### 传统的RSA握手

1. 客户端首先发送 client_random、TSL版本号、加密套件列表给服务器
2. 服务器在接收到之后确认TSL版本号，同时发送server_random、需要使用的加密套件、自己的证书给客户端
3. 客户端在收到这些信息之后，首先是会对服务器的证书进行验证，若是验证成功则会用RSA算法生成一个pre_random，且用服务器的公钥(在证书中)加密pre_random发送给服务器。
4. 此时，客户端有了 client_random、server_random、pre_random，它会将这三个参数通过一个**伪随机函数**计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。
5. 服务器接收到了刚刚用自己公钥加密的pre_random之后，用自己的私钥进行解密，得到里面的  pre_random，用和客户端一样的方式生成secret。
6. 之后就用这个 secret对称密钥加密报文传输



###### ECDHE握手

1. 客户端在第一次发送HTTPS请求的时候，会把 client_random、TSL版本号、加密套件列表发送给服务器
2. 服务器在接收到之后确认TSL的版本号，同时发送 server_random、server_params、需要使用的加密套件、以及自己的证书给客户端
3. 客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会传递一个 client_params 给服务器
4. 与此同时客户端会通过**ECDHE算法**计算出一个pre_random，其中是传入了两个参数，一个是 client_params，还一个是 server_params。(也就是说：ECDHE(client_params, server_params) = per_random)
5. 这时候客户端就同时拥有了 client_random、server_random、pre_random，它会将这三个参数通过一个**伪随机函数**计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。
6. 而在客户端生成完secret之后，会给服务器发送一个收尾消息，告诉服务器之后都要用对称加密，且对称加密的算法是用第一次约定好的。
7. 服务器它在接收到刚刚传递过来的client_params之后，也会使用和客户端一样的方式生成secret，并且也会发送一个收尾消息给客户端。
8. 当双方都收到收尾消息并验证成功之后，握手就结束了。后面开始用这个secret对称密钥加密报文进行传输。

（ECDHE基于**椭圆曲线离散对数**，传入的两个参数也被叫做**椭圆曲线的公钥**）

###### 那么ECDHE握手和RSA握手又有什么区别呢？

1. 生成secret(对称密钥)的过程不同。RSA中是使用RSA算法生成一个pre_random并用服务器的公钥加pre_random发送给服务器，然后各自用伪随机函数生成相同的secret对称密钥；而在ECDHE握手中，它没有用到RSA算法，而是用ECDHE算法生成的pre_random，且这个过程中比RSA多了client_params和server_params两个参数。
2. 在生成完secret之后，ECDHE握手在客户端发送完收尾消息后可以提前`抢跑`，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫`TLS False Start`。
3. 最主要的：RSA不具备向前安全性，ECDHE有向前安全性（一次破解并不影响历史信息的性质就是向前安全性）

###### 向前安全性

比如在RSA握手的过程中，客户端拿到了服务端的公钥，然后用此公钥加密pre_random给服务端。如果此时有第三方有服务端的私钥，并且截获了之前所有报文的时候，那么它就可以破解这段密文并拿到pre_random、client_random、server_random并根据对应的伪随机函数生成secret，即拿到了最终通信的对称密钥，每一个历史报文都能通过这样的方式进行破解。它就不具有向前安全性。

但是ECDHE在每次握手的时候都会产生一个零时的密钥对(也就是client_params、server_params)，即使第三方有了私钥能破解，但是对之前的历史报文并没有影响。它就具有向前安全性。

#### 9. HTTP请求方法中的options方法有什么用

```
OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。
```

