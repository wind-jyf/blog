# 从URL输入到页面生成的过程

## 整体过程

从输入URL到页面生成大致有以下步骤：

1. URL解析
2. DNS查询，将URL转为IP地址
3. 建立TCP连接
4. 发起HTTP请求
5. 服务器响应HTTP，并返回内容
6. 浏览器收到资源
7. 浏览器进行渲染，建立DOM，CSSOM树->构建渲染树->布局渲染树->绘制渲染树

## 一、URL解析

#### 地址解析：

首先判断你输入的是一个合法的URL还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。

#### 查找缓存

## 二、DNS查询

![img](https://user-gold-cdn.xitu.io/2019/8/22/16cb90a455e33ed2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 根域名服务器查询

如果在缓存中没有找到，则会向根域名服务器发起请求，进行查询，但是查询的方式有两种：

1. 递归查询
2. 迭代查询

![递归查询和迭代查询](https://pic1.zhimg.com/80/v2-b6cf454b2fc9144470f097c827a13ab0_1440w.jpg)

根据域名的层次结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。

在迭代查询中，比如我们想要查询www.baidu.com的IP地址，我们首先会将请求发送到本地的DNS服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责.com的顶级域名服务器的IP地址的列表。然后本地DNS服务器再向其中一个负责.com的顶级域名服务器发送一个请求，负责.com的顶级域名服务器返回负责.baidu的权威域名服务器的IP地址列表。然后本地DNS服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的IP地址列表。

使用递归查询，用户只需要发出一次查询请求。使用迭代查询，用户需要发出多次的查询请求。

**一般我们向本地DNS服务器发送请求的方式就是递归查询，但本地DNS服务器向其他域名服务器请求的过程是迭代查询的过程。**

## 三、建立TCP连接

#### TCP三次握手

1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
3. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 为什么不采用两次握手

采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。

## 四、发起HTTP请求

![img](https://user-gold-cdn.xitu.io/2019/8/22/16cb90a44ec17fbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接收到请求，就解析请求头，如果请求头中的头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200。

#### 浏览器缓存

浏览器缓存分为强缓存和协商缓存。强缓存和协商缓存的区别就在于强缓存不会向服务器发送请求，但是协商缓存会向服务器发送请求。

###### 强缓存

在使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以使用http头信息中的Expires（绝对时间）和cache-control（max-age相对时间 no-cache）属性来设置。

###### 协商缓存

如果此时强缓存失效时，就会进行协商缓存。

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回304状态，让浏览器直接使用本地的缓存。如果资源发生了修改，则服务器返回新的资源，并返回状态码200。

协商缓存也可以通过头信息进行设置，分别是`Etag`和`Last-Modified`。

服务器通过在响应头中添加`Last-Modified`属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个If-Modified-Since属性，属性值为上一次资源返回时的Last-Modified值。当请求发送到服务器后服务器会通过这个属性和资源的最后一次修改时间来进行比较，依次来判断资源是否被修改，如果没有被修改，则返回304，如果被修改了，则返回被修改后的数据，并返回200。

但是`Last-Modified`的时间只能精确到秒，如果在1秒内文件被修改了多次，也检测不出服务器端的资源被修改了，仍会返回304，造成资源并没有实时更新。

由于`Last-Modified`的不准确性，http提供了另一种方式，那就是`Etag`属性。服务器在返回资源的时候，向响应头中添加了`Etag`属性，这个属性是资源生成的唯一标识符，当资源发生变化的时候，这个标识符也会发生变化。在下一次客户端进行请求时，会在头信息中添加`If-None-Match`属性，这个属性的值来进行比较资源是否发生变化。

## 五、服务器响应请求

在服务器响应请求之后，将结果返回给浏览器后，TCP会进行四次挥手来断开连接。

- 第一次挥手，告诉服务器，我已经不会再给你发数据了（当然，如果之前的数据没有接受成功，还是会重新发）客户端进入FIN-WAIT-1（终止等待1）状态
- 第二次挥手，服务器还是正常的发送数据，但是他会高速高层，客户端向服务器的方向已经断了，这时候处于半关闭，但是还可以发数据，此时服务器处于CLOSE-WAIT。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- 第三次挥手，还是服务器，服务器告诉客户端FIN=1，表示我的数据也发完了，处于半关闭状态，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 为什么客户端最后还要等待2MSL

> MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

#### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

因为建立的时候不发数据，而关闭的时候，服务器还有数据没发完，不能立即结束。

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

## 六、浏览器收到资源

浏览器接收到来自服务器的响应资源后，会对资源进行分析。

首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。

如果响应资源进行了压缩（比如 gzip），还需要进行解压。

然后，对响应资源做缓存。

接下来，根据响应资源里的 [MIME](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types) 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。

#### 准备渲染进程

默认情况下，Chrome会为每个页面分配一个渲染进程，也就是说，每打卡一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

**如果从一个页面打卡了另一个页面，而新页面和当前页面属于同一个站点的话，那么新页面会复用父页面的渲染进程**

#### 提交文档

这里的“文档”指的是URL请求的响应体数据。

“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”消息后，会和网络进程建立传输数据的“管道”。

等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程。

## 七、渲染页面

![img](https://user-gold-cdn.xitu.io/2019/8/22/16cb90a48573cead?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

一旦文档被提交，渲染进程便开始页面解析和子资源加载了。

在渲染进程中，先后会进行构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

#### 构建DOM树

 **因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树**

虽然DOM和HTML内容几乎是一样的，但是和HTML不同的是，DOM是保存在内存的树状结构，可以通过JavaScript来查询或修改内容。

现在我们已经生成DOM树了，但是DOM节点的样式我们仍然不知道，要让DOM节点拥有正确的样式，这就需要样式计算了。

#### 样式计算

样式计算的目的是为了计算出DOM节点中的每个元素的具体样式，这个阶段大体可分为三步来完成。

###### 1. 把CSS转换为浏览器能够理解的结构

和HTML文件一样，浏览器也是无法直接理解这些纯文本的CSS样式，所以当**渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheet。**

###### 2. 转换样式表中的属性值，使其标准化

现在我们已经将CSS文本转换为浏览器可以理解的结构了，那么**接下来就要对其进行属性值的标准化操作。**

```css
body{
	font-size:2em;
}
```

一般我们的数值单位有很多中，例如em，rpx，rem等等。这些类型数值不容易被渲染引擎理解，所以**需要将所有值转换为渲染引擎容易理解的、标准化的计算值**，这个过程就是属性值的标准化。

一般会把字体单位统一转换为px，颜色单位统一转为rgb。

###### 3. 计算出DOM树中每个节点的样式

根据CSS的基础规则以及层叠规则计算出每个节点的样式。

#### 布局阶段

现在，我们有DOM树和DOM树中元素的样式，但这害不足以显示页面，因为我们害不知道DOM元素的几何位置信息。**那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。**

Chrome在布局阶段需要完成两件事：构建布局树和布局计算

###### 1. 创建布局树

由于有些标签使用了`display:none`属性的元素。所以在显示之前，**我们需要额外地构建一棵只包含可见元素布局树。**

###### 2. 布局计算

#### 分层

由于页面中有许多复杂的效果，比如使用了`z-index`属性，为了更方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。**

#### 合成

现在渲染进程知道了DOM结构，每个元素的样式，元素在页面上的几何位置，元素的渲染先后。渲染进程将这些信息转换为屏幕上的像素的过程被叫做**栅格化**。

合成是一种将页面的各个部分进行分层的技术，分别对不同的图层进行栅格化，并在合成线程中作为页面进行合成。因为图层都已经被栅格化，在发生滚动的时候，只需要进行图层的移动来合成一个新的帧就行了。

当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，因为有些图层可能会很大，比如有些界面需要滚动好久才能滚动到底部，这时候，合成线程就会将图层划分为图块来优先满足 浏览器可视区域的渲染，这些图块的大小通常是256X256或者512X512， 然后合成线程会按照 可视区域附近的图块来优先生成位图，这里生成位图的操作就是栅格化。

栅格化的过程会使用**GPU来加速生成**，使用GPU生成位图的过程叫做**快速栅格化**，或者**GPU栅格化**，生成的位图都被保存在GPU内存中。

一旦所有的图块都被栅格化，合成线程就会生成一个绘制图块的命令--“**Draw Quad**”, 然后将该命令提交给浏览器进程。 浏览器进程接收到命令后，会将页面内容绘制到内存中，最后再将内存显示在屏幕上。

> 使用CSS动画效果，可以避免排列和绘制阶段，直接在合成线程或光栅化线程池中进行操作，因为并没有占用主线程，所以直接合成的效率是最高的。

#### 总结渲染进程

1. 将HTML转换为DOM树
2. 将CSS转换为styleSheets，将属性值标准化，并计算出其样式
3. 通过DOM树和styleSheets生成布局树，并进行位置计算
4. 对布局树进行分层，生成分层树
5. 对每个图层生成绘制表，交给合成线程
6. 合成线程将每个图层分为图块，并在光栅化线池中将图块转换为位图，中间可能伴有GPU加速
7. 合成线程发送DrawQuad（绘制图块命令）给浏览器进程。
8. 浏览器会根据DrawQuad消息生成页面，并显示到显示器上。